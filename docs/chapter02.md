### 2.1 리팩터링 정의

- 특정한 방식에 따라 코드를 정리하는 것만 리팩토링이다.
- 리팩터링 과정에서 발견된 버그는 리팩터링 후에도 그대로 남아있어야한다.
- 리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다.

### 2.3 리팩터링하는 이유

- 중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있어며, 이는 바람직한 설계의 핵심이다.

### 2.4 언제 리팩터링행야 할까?

- “잠깐, 지도를 보고 가장 빠른 경로를 찾아보자”고 말할 줄 알아야 한다. 준비를 위한 리팩터링이 바로 이런 역할을 한다.(제시카 커)
- 그 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다.
- 쓰레기 줍기 리팩터링
- 어제 적합했던 기준이 오늘 하는 다른 작업에는 맞지 않을 수 있다. 이렇게 상황이 변해 기준을 변경해야 할 때 코드는 이미 깔끔하다면 리팩터링하기가 더 쉽다.
- 계획된 리팩터링을 하게되는 일은 최소한으로 줄여야 한다. 리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야한다.
- 팀 전체가 리팩터링에 매달리는 데는 회의적이다. 주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적일 때가 많다.
- 코드 리뷰를 하면 다른 사람의 아이디어를 얻을 수 있다는 장점도 있다.
- 코드 작성자가 참석해야 맥락을 설명해줄 수 있고 작성자도 리뷰어의 변경의도를 제대로 이해할 수 있으므로, 이왕이면 참석자가 참석하는 방식이 좋다. 내가 경험한가장 좋은 방ㅂ버은 작성자와 나란히 않아서 코드를 훑어가면서 리팩터링하는 것이다. 짝 프로그래밍
- 나는 지저분한 코드를 발견해도 굳이 수정할 필요가 없다면 리팩터링하지 않는다. 외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둔다
- 리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때도 리팩터링 하지 않는다.
- 리팩터링은 갭라기간을 단추갛고자 하는 것이다. 기능 추가 시간을 줄이고, 버그 수정 시간을 줄여준다.
- 브랜치를 자주 통합할 수만 있다면 문제가 발생할 가능성을 크게 줄일 수 있다.
- 자가 테스트 코드는 리팩터링을 할 수 있게 해줄 뿐만 아니라, 새기능 추가도 안전하게 진행할 수 있도록 도와준다. 실수로 만든 버그를 빠르게 찾아서 제거할 수 있기 때문이다.
- 데이터 베이스 리팩터링은 프로덕션 환경에서 여러 단계로 나눠서 릴리스 하는 것이 대체로 좋다는 점에서 다른 리팩터링과 다르다.
    1. 새 필드 추가하고 사용하지 않는다.
    2. 기존 필드와 새 필드를 동시에 사용한다.
    3. 클라이언트 조금씩 교체
    4. 기존 필드삭제

### 2.6 리팩터링, 아키텍처, 애그니YAGNI

- 리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드베이스를 잘 설계해준다는 데 있다.
- 유연성 매커니즘
- YAGNI: 나중에 문제를 더 깊이 이해하게 됐을 때 처리하는 쪽이 훨씬 낫다고 생각

### 2.7 리팩터링과 소프트웨어 개발 프로세스

- 자가 테스트 코드와 리팩터링을 묶어서 테스트 주도 개발이라한다.
- 자가 테스트 코드, 지속적 통합, 리팩터링 = 강력한 상승효과
- 지속적 배포는 소프트웨어를 언제든 릴리스할 수 있는 상태로 유지해준다.

### 2.8 리팩터링과 성능

- 리팩터링하면 소프트웨어가 느려질 수도 있는 건 사실이다. 하지만 그와 동시에 성능을 튜닝하기는 더 쉬워진다.
    - 먼저 튜닝하기 쉽게 만들고 나서 원하는 속도가 나게끔 튜닝하는 것
